# -*- coding: utf-8 -*-
"""K-Means Clustering on the Gene Cube

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i87KkHypJZVKjs2Nu7GTVNpbqrPR9DIq
"""

import sys
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pickle
import random
import time
import warnings
import seaborn as sns

from sympy import ceiling

from scipy.spatial import distance
from scipy import floor

from io_methods import read_data_from_excel, save_cluster_genes

from Array3D import Array3D

from mykmeans import KMeans
from mykmeans3D import KMeans3D
from DeltaTrimax import DeltaTrimax

from plotting_tools import plot_array3D_slices, plot_significant_clusters3D, plot_significant_centroids3D, plot_contour, plot_clusters3D, plot_centroids3D, plot_boxplot

from sympy import ceiling, floor
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

import seaborn as sns

import warnings


def plot_boxplot(data, xlabels=None, figsize=(8, 5), fontsize=16,
                 filename=None, dpi=150, paper_style=False,
                 figurename='boxplot'):

    fig = plt.figure(figurename, figsize=figsize)

    if (paper_style):
        sns.set_context("paper")
        sns.set_style("white")   # Membuat background berwarna putih

    plt.boxplot(data)

    plt.xlabel('sampel', fontsize=fontsize, fontname='Times New Roman')
    plt.xticks(range(data.shape[2]+1), fontname='Times New Roman')
    if (xlabels is not None):
        plt.xticks(range(len(xlabels)+1), xlabels, rotation=90)
    plt.ylabel('ekspresi gen', fontsize=fontsize, fontname='Times New Roman')
    plt.yticks(range(-5, 45, 5), fontname='Times New Roman')

    if (paper_style):
        sns.despine(fig)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
    fig.show()


def plot_array3D_slices(arr, start_slice=0, stop_slice=None, xlabels=None,
                        centroids=None, n_subplots=4, figsize=(17.075, 8.1125),
                        filename=None, dpi=150, fontsize=8, paper_style=False):

    if (stop_slice is None):
        stop_slice = arr.shape[1]
    n_slices = stop_slice - start_slice

    no_windows = (n_slices // n_subplots)
    if (n_slices % n_subplots > 0):
        no_windows += 1

    curr_slice = start_slice
    for win in range(1, no_windows+1):
        figurename = "Slice " + str(start_slice) + " sampai " + str(stop_slice) + " bagian " + str(win)
        fig = plt.figure(figurename, figsize=figsize)
        while (curr_slice - start_slice < n_slices) and (curr_slice - start_slice < win*n_subplots):
            if (n_subplots > 1):
                if ((n_slices // n_subplots) - win < 0):
                    plt.subplot(ceiling((n_slices % n_subplots) / 2.0), 2, ((curr_slice-start_slice) % n_subplots)+1)
                else:
                    plt.subplot(ceiling(n_subplots/2), 2, ((curr_slice-start_slice) % n_subplots)+1)

            if (paper_style):
                sns.set_context("paper")
                sns.set_style("white")   # Membuat background berwarna putih

            if (xlabels is not None):
                plt.xticks(range(arr.shape[2]),
                           xlabels,
                           rotation=25)
            plt.xticks(fontsize=fontsize, fontname='Times New Roman')
            plt.xlim(0, arr.shape[2]-1)

            plt.yticks(fontsize=fontsize, fontname='Times New Roman')

            if (paper_style):
                sns.set_context("paper")
                sns.set_style("white")   # Membuat background berwarna putih

            n_gen = 0
            for kromosom in range(arr.shape[0]): # untuk setiap gen pada slice
                plt.plot(range(arr.shape[2]), arr[kromosom, curr_slice, :], linewidth=1)
                if (not np.isnan(arr[kromosom, curr_slice, :]).all()):
                    n_gen += 1
            if (centroids is not None):
                plt.plot(range(arr.shape[2]), centroids[curr_slice, :],
                         color='k', linewidth=2)

            if (n_gen == 1):
                plt.title('Slice ' + str(curr_slice) + ' (' + str(n_gen) + ' gen)', fontname='Times New Roman', fontsize=fontsize+2)
            else:
                plt.title('Slice ' + str(curr_slice) + ' (' + str(n_gen) + ' gen)', fontname='Times New Roman', fontsize=fontsize+2)

            curr_slice += 1
            if (paper_style):
                sns.despine(fig)

        fig.tight_layout()
        if (filename is not None):
            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
        fig.show()

def plot_clusters3D(n_clusters, arr, mode, labels, centroids=None,
                    xlabels=None, n_subplots=4, figsize=(17.075, 8.1125),
                    filename=None, dpi=150, fontsize=8, paper_style=False):

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    for win in range(1, no_windows+1):
        figurename = "n_clusters=" + str(n_clusters) + "_" + str(win) + "_mode" + str(mode)
        fig = plt.figure(figurename, figsize=figsize)
        while (clust < n_clusters) and (clust < win*n_subplots):
            if (n_subplots > 1):
                if ((n_clusters // n_subplots) - win < 0):
                    plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
                else:
                    plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

            if (paper_style):
                sns.set_context("paper")
                sns.set_style("white")   # Membuat background berwarna putih

            cluster_gen = np.where(labels == clust)[0]

            if (len(cluster_gen) == 1):
                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slice)', fontname='Times New Roman', fontsize=fontsize+2)
            else:
                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)

            if (mode == 0) or (mode == 1):
                if (xlabels is not None):
                    plt.xticks(range(arr.shape[2]),
                                     xlabels,
                                     rotation=25)
                plt.xlim(0, arr.shape[2]-1)
            else:
                if (xlabels is not None):
                    plt.xticks(range(arr.shape[1]),
                                     xlabels,
                                     rotation=25)
                plt.xlim(0, arr.shape[1]-1)

            plt.xticks(fontsize=fontsize, fontname='Times New Roman')

            plt.yticks(fontsize=fontsize, fontname='Times New Roman')

            for gen_group in cluster_gen:  # untuk setiap gen pada cluster
                if (mode == 0):
                    for gen in arr[gen_group, :, :]:
                        plt.plot(range(arr.shape[2]), gen, linewidth=1)
                elif (mode == 1):
                    for gen in arr[:, gen_group, :]:
                        plt.plot(range(arr.shape[2]), gen, linewidth=1)
                else:
                    for sampel in arr[:, :, gen_group]:
                        plt.plot(range(arr.shape[1]), sampel, linewidth=1)
            if (centroids is not None):
                if (mode == 0):
                    plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                             linewidth=2)
                elif (mode == 1):
                    plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                             linewidth=2)
                else:
                    plt.plot(range(arr.shape[1]), centroids[clust, :], color='k',
                             linewidth=2)
            clust += 1
            if (paper_style):
                sns.despine(fig)

        fig.tight_layout()       
        if (filename is not None):
            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
    

def plot_clusters2D(n_clusters, arr, labels, centroids=None, xlabels=None,
                    n_subplots=4, figsize=(17.075, 8.1125), filename=None,
                    dpi=150, fontsize=8, paper_style=False):

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    for win in range(1, no_windows+1):
        figurename = "n_clusters=" + str(n_clusters) + ",_" + str(win)
        fig = plt.figure(figurename, figsize=figsize)
        while (clust < n_clusters) and (clust < win*n_subplots):
            if (n_subplots > 1):
                if ((n_clusters // n_subplots) - win < 0):
                    plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
                else:
                    plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

            if (paper_style):
                sns.set_context("paper")
                sns.set_style("white")   # Membuat background berwarna putih

            cluster_gen = np.where(labels == clust)[0]

            if (len(cluster_gen == 1)):
                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slice)', fontname='Times New Roman', fontsize=fontsize+2)
            else:
                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)

            if (xlabels is not None):
                plt.xticks(range(arr.shape[1]),
                           xlabels,
                           rotation=25)
            plt.xlim(0, arr.shape[1]-1)
            plt.xticks(fontsize=fontsize, fontname='Times New Roman')
            plt.yticks(fontsize=fontsize, fontname='Times New Roman')

            for gen in cluster_gen:  # untuk setiap gen pada cluster
                plt.plot(range(arr.shape[1]), arr[gen, :], linewidth=1)
            if (centroids is not None):
                plt.plot(range(arr.shape[1]), centroids[clust, :], color='k',
                         linewidth=2)
            clust += 1
            if (paper_style):
                sns.despine(fig)

        fig.tight_layout()
        if (filename is not None):
            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
        fig.show()


def plot_significant_clusters3D(n_clusters, arr, mode, labels, centroids=None,
                                xlabels=None, n_subplots=4,
                                figsize=(17.075, 8.1125), filename=None,
                                dpi=150, fontsize=8, paper_style=False):

    subplots = 1
    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_1_mode" + str(mode)
    fig = plt.figure(figurename, figsize=figsize)
    i = 2
    for clust in range(n_clusters):
        cluster_gen = np.where(labels == clust)[0]
        if (len(cluster_gen) > 1):
            if (n_subplots == 1):
                # Tidak akan membuat subplot
                if (subplots == 2):
                    # Harus membuka layar baru
                    fig.tight_layout()
                    if (filename is not None):
                        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                    fig.show()
                    subplots = 1
                    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i) + "_mode" + str(mode)
                    fig = plt.figure(figurename, figsize=figsize)
                    i += 1

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Make the background white

                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)

                subplots += 1

                if (mode == 0) or (mode == 1):
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[2]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[2]-1)
                else:
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[1]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[1]-1)

                plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                plt.yticks(fontsize=fontsize, fontname='Times New Roman')

                for gen_group in cluster_gen:  # untuk setiap gen pada cluster
                    if (mode == 0):
                        for gen in arr[gen_group, :, :]:
                            plt.plot(range(arr.shape[2]), gen, linewidth=1)
                    elif (mode == 1):
                        for gen in arr[:, gen_group, :]:
                            plt.plot(range(arr.shape[2]), gen, linewidth=1)
                    else:
                        for sampel in arr[:, :, gen_group]:
                            plt.plot(range(arr.shape[1]), sampel, linewidth=1)
                if (centroids is not None):
                    if (mode == 0):
                        plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                                 linewidth=2)
                    elif (mode == 1):
                        plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                                 linewidth=2)
                    else:
                        plt.plot(range(arr.shape[1]), centroids[clust, :], color='k',
                                 linewidth=2)
                if (paper_style):
                    sns.despine(fig)
            else:
                if (subplots == n_subplots+1):
                    fig.tight_layout()
                    if (filename is not None):
                        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                    fig.show()
                    subplots = 1
                    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i) + "_mode" + str(mode)
                    fig = plt.figure(figurename, figsize=figsize)
                    i += 1
                plt.subplot(ceiling(n_subplots/2), 2, subplots)
                subplots += 1

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)

                if (mode == 0) or (mode == 1):
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[2]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[2]-1)
                else:
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[1]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[1]-1)

                plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                plt.yticks(fontsize=fontsize, fontname='Times New Roman')

                for gen_group in cluster_gen:  # untuk setiap gen pada cluster
                    if (mode == 0):
                        for gen in arr[gen_group, :, :]:
                            plt.plot(range(arr.shape[2]), gen, linewidth=1)
                    elif (mode == 1):
                        for gen in arr[:, gen_group, :]:
                            plt.plot(range(arr.shape[2]), gen, linewidth=1)
                    else:
                        for sampel in arr[:, :, gen_group]:
                            plt.plot(range(arr.shape[1]), sampel, linewidth=1)
                if (centroids is not None):
                    if (mode == 0):
                        plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                                 linewidth=2)
                    elif (mode == 1):
                        plt.plot(range(arr.shape[2]), centroids[clust, :], color='k',
                                 linewidth=2)
                    else:
                        plt.plot(range(arr.shape[1]), centroids[clust, :], color='k',
                                 linewidth=2)
                if (paper_style):
                    sns.despine(fig)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
    fig.show()


def plot_significant_clusters2D(n_clusters, arr, labels, centroids=None,
                                xlabels=None, n_subplots=4,
                                figsize=(17.075, 8.1125), filename=None,
                                dpi=150, fontsize=8, paper_style=False):

    subplots = 1
    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_1"
    fig = plt.figure(figurename, figsize=figsize)
    i = 2
    for clust in range(n_clusters):
        cluster_gen = np.where(labels == clust)[0]
        if (len(cluster_gen) > 1):
            if (n_subplots == 1):
                # Tidak akan dibuat subplot
                if (subplots == 2):
                    # Harus membuka layar baru
                    fig.tight_layout()
                    if (filename is not None):
                        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                    fig.show()
                    subplots = 1
                    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i)
                    fig = plt.figure(figurename, figsize=figsize)
                    i += 1
                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)
                subplots += 1

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                if (xlabels is not None):
                    plt.xticks(range(arr.shape[1]),
                               xlabels,
                               rotation=25)

                plt.xlim(0, arr.shape[1]-1)
                plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                plt.yticks(fontsize=fontsize, fontname='Times New Roman')

                for gen in cluster_gen:
                    plt.plot(range(arr.shape[1]), arr[gen, :], linewidth=1)
                if (centroids is not None):
                    plt.plot(range(arr.shape[1]), centroids[clust, :],
                             color='k', linewidth=2)
                if (paper_style):
                    sns.despine(fig)
            else:
                if (subplots == n_subplots+1):
                    fig.tight_layout()
                    if (filename is not None):
                        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
                    fig.show()
                    subplots = 1
                    figurename = "Signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i)
                    fig = plt.figure(figurename, figsize=figsize)
                    i += 1
                plt.subplot(ceiling(n_subplots/2), 2, subplots)
                subplots += 1

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)
                if (xlabels is not None):
                    plt.xticks(range(arr.shape[1]),
                               xlabels,
                               rotation=25)

                plt.xlim(0, arr.shape[1]-1)
                plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                plt.yticks(fontsize=fontsize, fontname='Times New Roman')

                for gen in cluster_gen:
                    plt.plot(range(arr.shape[1]), arr[gen, :], linewidth=1)
                if (centroids is not None):
                    plt.plot(range(arr.shape[1]), centroids[clust, :],
                             color='k', linewidth=2)
                if (paper_style):
                    sns.despine(fig)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
    fig.show()


def plot_centroids2D(n_clusters, arr, labels, xlabels=None, n_subplots=4,
                     error_bars='sd', figsize=(17.075, 8.1125), filename=None,
                     dpi=150, fontsize=8, paper_style=False):

    ymax = ceiling(np.nanmax(arr))

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    with warnings.catch_warnings():  # Terdapat mean dari NaN disini
        warnings.simplefilter("ignore", category=RuntimeWarning)
        for win in range(1, no_windows+1):
            figurename = "Centroid dari n_clusters=" + str(n_clusters) + "_" + str(win) + '_' + error_bars
            fig = plt.figure(figurename, figsize=figsize)
            while (clust < n_clusters) and (clust < win*n_subplots):
                if (n_subplots > 1):
                    if ((n_clusters // n_subplots) - win < 0):
                        plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
                    else:
                        plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                plt.title('Cluster ' + str(clust), fontname='Times New Roman', fontsize=fontsize+2)
                if (xlabels is not None):
                    plt.xticks(range(arr.shape[1]),
                               xlabels,
                               rotation=25)
                plt.xlim(0, arr.shape[1]-1)
                plt.xticks(fontsize=fontsize, fontname='Times New Roman')

                plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')

                # Mencari indeks gen dari cluster terkait
                cluster_gen = np.where(labels == clust)[0]
                # Menghitung centroid
                centroid = np.nanmean(arr[cluster_gen, :], axis=0)

                # Menghitung error dari setiap sampel
                if (error_bars == 'range'):
                    divergence = arr[cluster_gen, :] - centroid
                    errors = []
                    errors.append(np.absolute(np.nanmin(divergence, axis=0)))
                    errors.append(np.absolute(np.nanmax(divergence, axis=0)))
                else:
                    errors = np.nanstd(arr[cluster_gen, :])

                # Plot centroid dengan with error bars
                plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                clust += 1
                if (paper_style):
                    sns.despine(fig)

            fig.tight_layout()
            if (filename is not None):
                plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
            fig.show()


def plot_centroids3D(n_clusters, arr, mode, labels, xlabels=None,
                     n_subplots=4, error_bars='range',
                     figsize=(17.075, 8.1125), filename=None, dpi=150,
                     fontsize=8, paper_style=False):

    ymax = ceiling(np.nanmax(arr))

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    with warnings.catch_warnings():  # Terdapat mean dari NaN disini
        warnings.simplefilter("ignore", category=RuntimeWarning)
        for win in range(1, no_windows+1):
            figurename = "Centroid dari n_clusters=" + str(n_clusters) + "_" + str(win) + "_mode" + str(mode) + '_' + error_bars
            fig = plt.figure(figurename, figsize=figsize)
            while (clust < n_clusters) and (clust < win*n_subplots):
                if (n_subplots > 1):
                    if ((n_clusters // n_subplots) - win < 0):
                        plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
                    else:
                        plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                plt.title('Cluster ' + str(clust), fontname='Times New Roman', fontsize=fontsize+2)

                if (mode == 0) or (mode == 1):
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[2]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[2]-1)
                else:
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[1]),
                                   xlabels,
                                   rotation=25)
                    plt.xlim(0, arr.shape[1]-1)

                plt.xticks(fontsize=fontsize, fontname='Times New Roman')

                plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')

                # Mencari indeks gen dari cluster terkait
                cluster_gen = np.where(labels == clust)[0]

                # Menghitung centroid dan error untuk setiap sampel
                # dan memplot hasilnya
                if (mode == 0):
                    centroid = np.nanmean(np.nanmean(arr[cluster_gen, :, :], axis=0), axis=0)
                    if (error_bars == 'range'):
                        divergence = arr[cluster_gen, :, :] - np.broadcast_to(centroid, (len(cluster_gen), arr.shape[1], arr.shape[2]))
                        errors = []
                        errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=0), axis=0)))
                        errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=0), axis=0)))
                    else:
                        errors = np.nanstd(np.nanstd(arr[cluster_gen, :, :], axis=1), axis=0)
                    plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                elif (mode == 1):
                    centroid = np.nanmean(np.nanmean(arr[:, cluster_gen, :], axis=1), axis=0)
                    if (error_bars == 'range'):
                        divergence = arr[:, cluster_gen, :] - np.broadcast_to(centroid, (arr.shape[0], len(cluster_gen), arr.shape[2]))
                        errors = []
                        errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=1), axis=0)))
                        errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=1), axis=0)))
                    else:
                        errors = np.nanstd(np.nanstd(arr[:, cluster_gen, :], axis=1), axis=0)
                    plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                else:
                    centroid = np.nanmean(np.nanmean(arr[:, :, cluster_gen], axis=2), axis=0)
                    if (error_bars == 'range'):
                        divergence = arr[:, :, cluster_gen] - np.expand_dims(np.expand_dims(centroid, axis=0), axis=2)
                        errors = []
                        errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=2), axis=0)))
                        errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=2), axis=0)))
                    else:
                        errors = np.nanstd(np.nanstd(arr[:, :, cluster_gen], axis=2), axis=0)
                    plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                clust += 1
                if (paper_style):
                    sns.despine(fig)

            fig.tight_layout()
            if (filename is not None):
                plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
            fig.show()


def plot_significant_centroids2D(n_clusters, arr, labels, xlabels=None,
                                 n_subplots=4, error_bars='range',
                                 figsize=(17.075, 8.1125), filename=None,
                                 dpi=150, fontsize=8, paper_style=False):

    ymax = ceiling(np.nanmax(arr))

    subplots = 1
    figurename = "Significant centroids from n_clusters_" + str(n_clusters) + "_1_" + error_bars
    fig = plt.figure(figurename, figsize=figsize)
    i = 2
    with warnings.catch_warnings():  # Terdapat mean dari NaN disini
        warnings.simplefilter("ignore", category=RuntimeWarning)
        for clust in range(n_clusters):
            cluster_gen = np.where(labels == clust)[0]
            if (len(cluster_gen) > 1):
                if (n_subplots == 1):
                    # Tidak akan dibuat subplot
                    if (subplots == 2):
                        # Harus dibuka layar baru
                        fig.tight_layout()
                        if (filename is not None):
                            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                        fig.show()
                        subplots = 1
                        figurename = "Centroid signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i) + '_' + error_bars
                        fig = plt.figure(figurename, figsize=figsize)
                        i += 1
                    plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)
                    subplots += 1

                    if (paper_style):
                        sns.set_context("paper")
                        sns.set_style("white")   # Membuat background berwarna putih

                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[1]),
                                   xlabels,
                                   rotation=25)

                    plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                    plt.xlim(0, arr.shape[1]-1)

                    plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')
    
                    # Menghitung centroid dan error untuk setiap sampe
                    # dan memplot hasilnya
                    # Menghitung centroid
                    centroid = np.nanmean(arr[cluster_gen, :], axis=0)

                    # Menghitung error dari setiap sampel
                    if (error_bars == 'range'):
                        divergence = arr[cluster_gen, :] - centroid
                        errors = []
                        errors.append(np.absolute(np.nanmin(divergence, axis=0)))
                        errors.append(np.absolute(np.nanmax(divergence, axis=0)))
                    else:
                        errors = np.nanstd(arr[cluster_gen, :])
                    # Plot centroid dengan error bars
                    plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                    if (paper_style):
                        sns.despine(fig)
                else:
                    if (subplots == n_subplots+1):
                        fig.tight_layout()
                        if (filename is not None):
                            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
                        fig.show()
                        subplots = 1
                        figurename = "Centroid significant dari n_clusters_" + str(n_clusters) + "_" + str(i) + '_' + error_bars
                        fig = plt.figure(figurename, figsize=figsize)
                        i += 1
                    plt.subplot(ceiling(n_subplots/2), 2, subplots)
                    subplots += 1

                    if (paper_style):
                        sns.set_context("paper")
                        sns.set_style("white")   # Membuat background berwarna putih

                    plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)
                    if (xlabels is not None):
                        plt.xticks(range(arr.shape[1]),
                                   xlabels,
                                   rotation=25)

                    plt.xlim(0, arr.shape[1]-1)
                    plt.xticks(fontsize=fontsize, fontname='Times New Roman')

                    plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')

                    # Menghitung centroid dan error untuk setiap sampel
                    # dan memplot hasilnya
                    # Menghitung centroid
                    centroid = np.nanmean(arr[cluster_gen, :], axis=0)

                    # Menghitung error dari setiap sampel
                    if (error_bars == 'range'):
                        divergence = arr[cluster_gen, :] - centroid
                        errors = []
                        errors.append(np.absolute(np.nanmin(divergence, axis=0)))
                        errors.append(np.absolute(np.nanmax(divergence, axis=0)))
                    else:
                        errors = np.nanstd(arr[cluster_gen, :])
                    # Plot centroid dengan error bars
                    plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                    if (paper_style):
                        sns.despine(fig)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
    fig.show()


def plot_significant_centroids3D(n_clusters, arr, mode, labels, xlabels=None,
                                 n_subplots=4, error_bars='range',
                                 figsize=(17.075, 8.1125), filename=None,
                                 dpi=150, fontsize=8, paper_style=False):

    ymax = int(ceiling(np.nanmax(arr)))
    ymin = int(floor(np.nanmin(arr)))

    subplots = 1
    figurename = "Centroid signifikan dari n_clusters_" + str(n_clusters) + "_1_mode" + str(mode) + '_' + error_bars
    fig = plt.figure(figurename, figsize=figsize)
    i = 2
    with warnings.catch_warnings():  # Terdapat mean dari NaN disini
        warnings.simplefilter("ignore", category=RuntimeWarning)
        for clust in range(n_clusters):
            cluster_gen = np.where(labels == clust)[0]
            if (len(cluster_gen) > 1):
                if (n_subplots == 1):
                    # Tidak akan dibuat subplot
                    if (subplots == 2):
                        # Harus membuka layar baru
                        fig.tight_layout()
                        if (filename is not None):
                            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                        fig.show()
                        subplots = 1
                        figurename = "Centroid signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i) + "_mode" + str(mode) + '_' + error_bars
                        fig = plt.figure(figurename, figsize=figsize)
                        i += 1
                    plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_gen)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)
                    subplots += 1

                    if (paper_style):
                        sns.set_context("paper")
                        sns.set_style("white")   # Membuat background berwarna putih
        
                    if (mode == 0) or (mode == 1):
                        if (xlabels is not None):
                            plt.xticks(range(arr.shape[2]),
                                       xlabels,
                                       rotation=25)
                        plt.xlim(0, arr.shape[2]-1)
                    else:
                        if (xlabels is not None):
                            plt.xticks(range(arr.shape[1]),
                                       xlabels,
                                       rotation=25)
                        plt.xlim(0, arr.shape[1]-1)

                    plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                    plt.yticks(fontsize=fontsize, fontname='Times New Roman')
                    plt.ylim(ymin, ymax)

                    # Menghitung centroid dan error untuk setiap sampel
                    # dan memplot hasilnya
                    if (mode == 0):
                        centroid = np.nanmean(np.nanmean(arr[cluster_gen, :, :], axis=0), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[cluster_gen, :, :] - np.broadcast_to(centroid, (len(cluster_gen), arr.shape[1], arr.shape[2]))
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=0), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=0), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[cluster_gen, :, :], axis=1), axis=0)
                        plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                    elif (mode == 1):
                        centroid = np.nanmean(np.nanmean(arr[:, cluster_gen, :], axis=1), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[:, cluster_gen, :] - np.broadcast_to(centroid, (arr.shape[0], len(cluster_gen), arr.shape[2]))
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=1), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=1), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[:, cluster_gen, :], axis=1), axis=0)
                        plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                    else:
                        centroid = np.nanmean(np.nanmean(arr[:, :, cluster_gen], axis=2), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[:, :, cluster_genes] - np.expand_dims(np.expand_dims(centroid, axis=0), axis=2)
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=2), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=2), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[:, :, cluster_gen], axis=2), axis=0)
                        plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                    if (paper_style):
                        sns.despine(fig)
                else:
                    if (subplots == n_subplots+1):
                        fig.tight_layout()
                        if (filename is not None):
                            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
                        fig.show()
                        subplots = 1
                        figurename = "Centroid signifikan dari n_clusters_" + str(n_clusters) + "_" + str(i) + "_mode" + str(mode) + '_' + error_bars
                        fig = plt.figure(figurename, figsize=figsize)
                        i += 1
                    plt.subplot(ceiling(n_subplots/2), 2, subplots)
                    subplots += 1

                    if (paper_style):
                        sns.set_context("paper")
                        sns.set_style("white")   # Membuat background berwarna putih

                    plt.title('Cluster ' + str(clust) + ' (' + str(len(cluster_genes)) + ' slices)', fontname='Times New Roman', fontsize=fontsize+2)

                    if (mode == 0) or (mode == 1):
                        if (xlabels is not None):
                            plt.xticks(range(arr.shape[2]),
                                       xlabels,
                                       rotation=25)
                        plt.xlim(0, arr.shape[2]-1)
                    else:
                        if (xlabels is not None):
                            plt.xticks(range(arr.shape[1]),
                                       xlabels,
                                       rotation=25)
                        plt.xlim(0, arr.shape[1]-1)

                    plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                    plt.yticks(fontsize=fontsize, fontname='Times New Roman')
                    plt.ylim(ymin, ymax)

                    # Menghitung centroid dan error untuk setiap sampel
                    # dan memplot hasilnya
                    if (mode == 0):
                        centroid = np.nanmean(np.nanmean(arr[cluster_gen, :, :], axis=0), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[cluster_gen, :, :] - np.broadcast_to(centroid, (len(cluster_gen), arr.shape[1], arr.shape[2]))
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=0), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=0), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[cluster_gen, :, :], axis=1), axis=0)
                        plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                    elif (mode == 1):
                        centroid = np.nanmean(np.nanmean(arr[:, cluster_gen, :], axis=1), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[:, cluster_gen, :] - np.broadcast_to(centroid, (arr.shape[0], len(cluster_gen), arr.shape[2]))
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=1), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=1), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[:, cluster_gen, :], axis=1), axis=0)
                        plt.errorbar(range(arr.shape[2]), centroid, yerr=errors)
                    else:
                        centroid = np.nanmean(np.nanmean(arr[:, :, cluster_gen], axis=2), axis=0)
                        if (error_bars == 'range'):
                            divergence = arr[:, :, cluster_gen] - np.expand_dims(np.expand_dims(centroid, axis=0), axis=2)
                            errors = []
                            errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=2), axis=0)))
                            errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=2), axis=0)))
                        else:
                            errors = np.nanstd(np.nanstd(arr[:, :, cluster_gen], axis=2), axis=0)
                        plt.errorbar(range(arr.shape[1]), centroid, yerr=errors)

                    if (paper_style):
                        sns.despine(fig)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi, bbox_inches='tight')
    fig.show()


def nearest_neighbors(A, start):

    path = [start]
    cost = 0
    N = A.shape[0]
    mask = np.ones(N, dtype=bool)   # nilai boolean yang mengindikasikan
                                    # lokasi yang belum dikunjungi
    mask[start] = False

    for i in range(N-1):
        last = path[-1]

        # mencari minimum dari lokasi sisanya
        next_ind = np.argmax(A[last][mask])

        # ubah menjadi lokasi asli
        next_loc = np.arange(N)[mask][next_ind]

        path.append(next_loc)
        mask[next_loc] = False
        cost += A[last, next_loc]

    return path, cost


def plot_surface(n_clusters, centroids):

    # Menghitung koefisien korelasi pearson untuk setiap pasangan centroid
    pearson = np.corrcoef(centroids)

    # Menjalankan algoritma repetitive nearest neighbor untuk mencari
    # urutan kromosom berdasarkan lokasinya
    max_cost = ([], 0)
    for start in range(n_clusters):
        nn_sol = nearest_neighbors(pearson, start)
        if (nn_sol[1] > max_cost[1]):
            max_cost = nn_sol

    # Urutan terbaik berada pada max_cost[0]
    best_sol = max_cost[0]

    fig = plt.figure()
    ax = fig.gca(projection='3d')

    centroids_ordered = []
    for clust in best_sol:
        centroids_ordered.append(centroids[clust, :])
    centroids_ordered = np.asarray(centroids_ordered)

    X = range(centroids.shape[1])
    Y = range(n_clusters)
    X, Y = np.meshgrid(X, Y)
    ax.plot_surface(X, Y, centroids_ordered)

    ax.set_xlabel('sampel')
    ax.set_ylabel('clusters')
    ax.set_zlabel('ekspresi gen')


def plot_contour(n_clusters, centroids, mode, xlabels=None, plot_before=False,
                 figsize=(17.075, 8.1125), filename=None, dpi=150,
                 fontsize=8):

    if (plot_before):
        figurename = "Plot kontur untuk n_clusters=" + str(n_clusters) + " sebelum diurutkan"
        fig = plt.figure(figurename, figsize=figsize)
        X = range(centroids.shape[1])
        Y = range(n_clusters)
        X, Y = np.meshgrid(X, Y)
        cset = plt.contourf(X, Y, centroids, cmap="rainbow")
        plt.colorbar(cset)
        # Also cmap="viridis" or cmap=plt.cm.jet look nice

        if (mode == 0) or (mode == 1):
            plt.xlabel('sampel')
        else:
            plt.xlabel('gen')
        plt.ylabel('clusters')

        if (xlabels is not None):
            plt.xticks(range(centroids.shape[1]), xlabels, fontsize=fontsize,
                       rotation=25)
        else:
            plt.xticks(range(centroids.shape[1]),
                       range(1, centroids.shape[1]+1), fontsize=fontsize)

        if (n_clusters <= 100):
            plt.yticks(range(n_clusters), range(n_clusters), fontsize=fontsize)
        else:
            plt.yticks(range(n_clusters), ["-"] * n_clusters, fontize=fontsize)

        fig.tight_layout()
        if (filename is not None):
            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
        fig.show()

    # Menghitung koefisien korelasi pearson untuk setiap pasangan centroid
    pearson = np.corrcoef(centroids)

    # Menjalankan algoritma repetitive nearest neighbor untuk mencari
    # urutan kromosom berdasarkan korelasinya
    max_cost = nearest_neighbors(pearson, 0)
    for start in range(1, n_clusters):
        nn_sol = nearest_neighbors(pearson, start)
        if (nn_sol[1] > max_cost[1]):
            max_cost = nn_sol

    # Urutan terbaik berada pada max_cost[0]
    best_sol = max_cost[0]

    centroids_ordered = []
    for clust in best_sol:
        centroids_ordered.append(centroids[clust, :])
    centroids_ordered = np.asarray(centroids_ordered)

    X = range(centroids.shape[1])
    Y = range(n_clusters)
    X, Y = np.meshgrid(X, Y)

    figurename = "Plot kontur untuk n_clusters=" + str(n_clusters) + " setelah diurutkan"
    fig = plt.figure(figurename, figsize=figsize)
    cset = plt.contourf(X, Y, centroids_ordered, cmap="rainbow")
    plt.colorbar(cset)
    # Also cmap="viridis" or cmap=plt.cm.jet look nice

    if (mode == 0) or (mode == 1):
        plt.xlabel('sampel')
    else:
        plt.xlabel('gen')
    plt.ylabel('clusters')

    if (xlabels is not None):
        plt.xticks(range(centroids.shape[1]), xlabels, fontsize=fontsize,
                   rotation=25)
    else:
        plt.xticks(range(centroids.shape[1]),
                   range(1, centroids.shape[1]+1), fontsize=fontsize)

    if (n_clusters <= 100):
        plt.yticks(range(n_clusters), best_sol, fontsize=fontsize)
    else:
        plt.yticks(range(n_clusters), ["-"] * n_clusters)

    fig.tight_layout()
    if (filename is not None):
        plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
    fig.show()

    return best_sol


def plot_triclusters(n_clusters, arr, tri_kromosom, tri_gen, tri_sampel,
                     delta, l, xlabels=None, labels=None,
                     n_subplots=4, scaled=False, figsize=(17.075, 8.1125),
                     filename=None, dpi=150, paper_style=False, fontsize=8):

    tri_kromosom = np.vstack(tri_kromosom)
    tri_gen = np.vstack(tri_gen)
    tri_sampel = np.vstack(tri_sampel)

    triclusters_kromosom = [np.nonzero(tri_row)[0] for tri_row in tri_kromosom]
    triclusters_gen = [np.nonzero(tri_row)[0] for tri_row in tri_gen]
    triclusters_sampel = [np.nonzero(tri_row)[0] for tri_row in tri_sampel]

    if (scaled):
        ymax = int(ceiling(np.nanmax(arr)))

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    for win in range(1, no_windows+1):
        figurename = "n_clusters=" + str(n_clusters) + "_d" + str(delta) + "_l" + str(l)  + "_" + str(win)
        fig = plt.figure(figurename, figsize=figsize)
        while (clust < n_clusters) and (clust < win*n_subplots):
            if ((n_clusters // n_subplots) - win < 0):
                plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
            else:
                plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

            tri_kromosom = triclusters_kromosom[clust]
            tri_gen = triclusters_gen[clust]
            tri_sampel = triclusters_sampel[clust]

            if (paper_style):
                sns.set_context("paper")
                sns.set_style("white")   # Membuat background berwarna putih

            nonnan_gen = 0

            for kromosom in tri_kromosom:
                for gen in tri_gen:  # untuk setiap gen pada cluster
                    plt.plot(range(len(tri_sampel)),
                             arr[kromosom, gen, tri_sampel])
                    if (not np.isnan(arr[kromosom, gen, :]).all()):
                        nonnan_gen += 1
            plt.title("Cluster " + str(clust) + ": " + str(nonnan_gen) + " gen dari " + str(tri_kromosom.shape[0]) + " pasangan kromosom",
                      fontname='Times New Roman', fontsize=fontsize+2)

            plt.xlim(0, len(tri_sampel)-1)
            if (xlabels is not None):
                plt.xticks(range(len(tri_sampel)),
                           xlabels[tri_sampel],
                           rotation=25)
            plt.xticks(fontsize=fontsize, fontname='Times New Roman')
            if (scaled):
                plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')
            else:
                plt.yticks(fontsize=fontsize, fontname='Times New Roman')

            clust += 1
            if (paper_style):
                sns.despine(fig)

        fig.tight_layout()
        if (filename is not None):
            plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
        fig.show()


def plot_tricentroids(n_clusters, arr, tri_kromosom, tri_gen, tri_sampel,
                      delta, l, xlabels=None, n_subplots=4, error_bars='range',
                      figsize=(17.075, 8.1125), filename=None, dpi=150,
                      paper_style=False, fontsize=8):

    tri_kromosom = np.vstack(tri_kromosom)
    tri_gen = np.vstack(tri_gen)
    tri_sampel = np.vstack(tri_sampel)

    triclusters_kromosom = [np.nonzero(tri_row)[0] for tri_row in tri_kromosom]
    triclusters_gen = [np.nonzero(tri_row)[0] for tri_row in tri_gen]
    triclusters_sampel = [np.nonzero(tri_row)[0] for tri_row in tri_sampel]

    ymax = int(ceiling(np.nanmax(arr)))

    no_windows = (n_clusters // n_subplots)
    if (n_clusters % n_subplots > 0):
        no_windows += 1

    clust = 0
    with warnings.catch_warnings():  # Terdapat mean dari NaN disini
        warnings.simplefilter("ignore", category=RuntimeWarning)
        for win in range(1, no_windows+1):
            figurename = "Centroid dari n_clusters=" + str(n_clusters) + "_d" + str(delta) + "_l" + str(l) + "_" + str(win) + '_' + error_bars
            fig = plt.figure(figurename, figsize=figsize)
            while (clust < n_clusters) and (clust < win*n_subplots):
                if ((n_clusters // n_subplots) - win < 0):
                    plt.subplot(ceiling((n_clusters % n_subplots) / 2.0), 2, (clust % n_subplots)+1)
                else:
                    plt.subplot(ceiling(n_subplots/2), 2, (clust % n_subplots)+1)

                plt.title('Cluster ' + str(clust), fontname='Times New Roman', fontsize=fontsize+2)

                if (paper_style):
                    sns.set_context("paper")
                    sns.set_style("white")   # Membuat background berwarna putih

                tri_kromosom = triclusters_kromosom[clust]
                tri_gen = triclusters_gen[clust]
                tri_sampel = triclusters_sampel[clust]      

                if (xlabels is not None):
                    plt.xticks(range(len(tri_sampel)),
                               xlabels[tri_sampel],
                               rotation=25)
                plt.xticks(fontsize=fontsize, fontname='Times New Roman')
                plt.xlim(0, len(tri_sampel)-1)

                # Mendapatkan slice array 3D yang terkait dengan
                # tricluster
                tricluster = arr[tri_kromosom, :, :]
                tricluster = tricluster[:, tri_gen, :]
                tricluster = tricluster[:, :, tri_sampel]

                # Menghitung centroid dan error untuk setiap sampel
                # dan memplot hasilnya
                centroid = np.nanmean(np.nanmean(tricluster, axis=1), axis=0)
                if (error_bars == 'range'):
                    divergence = tricluster - np.broadcast_to(centroid, (len(tri_kromosom), len(tri_gen), len(tri_sampel)))
                    errors = []
                    errors.append(np.absolute(np.nanmin(np.nanmin(divergence, axis=1), axis=0)))
                    errors.append(np.absolute(np.nanmax(np.nanmax(divergence, axis=1), axis=0)))
                else:
                    errors = np.nanstd(np.nanstd(tricluster, axis=1), axis=0)
                plt.errorbar(range(len(tri_sampel)), centroid, yerr=errors)

                plt.yticks(range(ymax), fontsize=fontsize, fontname='Times New Roman')

                clust += 1
                if (paper_style):
                    sns.despine(fig)

            fig.tight_layout()
            if (filename is not None):
                plt.savefig(filename + '/' + figurename + '.png', dpi=dpi)
            fig.show()

"""# Data"""

data = pd.read_excel('GSE7476.xlsx')

newlbl = data.iloc[0].copy()
newlbl[0] = 'ID Gen'
newlbl[1] = 'Simbol Gen'
newlbl[2] = 'Kromosom'
data.columns = newlbl.values

data = data.iloc[2:]

data['Kromosom'] = data['Kromosom'].map({1: 1, 2: 2, 3: 3,
                                         4: 4, 5: 5, 6: 6, 7: 7,
                                         8: 8, 9: 9, 10: 10, 11: 11,
                                         12: 12, 13: 13, 14: 14,
                                         15: 15, 16: 16, 17: 17,
                                         18: 18, 19: 19, 20: 20,
                                         21: 21, 22: 22, 'X': 23,
                                         'Y': 24})

new_symbols = []
for symbol in data['Simbol Gen'].values:
    new_symbols.append(symbol.partition('///')[0])
data['Simbol Gen'] = new_symbols

newind1 = data['ID Gen'].values.copy()
newind2 = data['Simbol Gen'].values.copy()

data.index = [np.arange(len(data.values)), newind1, newind2]
data.index.names = ['index', 'ID Gen', 'Simbol Gen']
data.drop('ID Gen', axis=1, inplace=True)
data.drop('Simbol Gen', axis=1, inplace=True)

data = data.astype(float)

data.head()

data.shape

"""# Grouping the Data Based on the Chromosomes"""

grouped_kromosom = data.groupby('Kromosom', sort=False)

"""## Chromosome 1"""

grouped_kromosom.get_group(1)

"""## Chromosome 2"""

grouped_kromosom.get_group(2)

"""## Chromosome 3"""

grouped_kromosom.get_group(3)

"""## Chromosome 4"""

grouped_kromosom.get_group(4)

"""## Chromosome 5"""

grouped_kromosom.get_group(5)

"""## Chromosome 6"""

grouped_kromosom.get_group(6)

"""## Chromosome 7"""

grouped_kromosom.get_group(7)

"""## Chromosome 8"""

grouped_kromosom.get_group(8)

"""## Chromosome 9"""

grouped_kromosom.get_group(9)

"""## Chromosome 10"""

grouped_kromosom.get_group(10)

"""## Chromosome 11"""

grouped_kromosom.get_group(11)

"""## Chromosome 12"""

grouped_kromosom.get_group(12)

"""## Chromosome 13"""

grouped_kromosom.get_group(13)

"""## Chromosome 14"""

grouped_kromosom.get_group(14)

"""## Chromosome 15"""

grouped_kromosom.get_group(15)

"""## Chromosome 16"""

grouped_kromosom.get_group(16)

"""## Chromosome 17"""

grouped_kromosom.get_group(17)

"""## Chromosome 18"""

grouped_kromosom.get_group(18)

"""## Chromosome 19"""

grouped_kromosom.get_group(19)

"""## Chromosome 20"""

grouped_kromosom.get_group(20)

"""## Chromosome 21"""

grouped_kromosom.get_group(21)

"""## Chromosome 22"""

grouped_kromosom.get_group(22)

"""## Chromosome 23"""

grouped_kromosom.get_group(23)

"""## Chromosome 24"""

grouped_kromosom.get_group(24)

"""# Formation of the 3D Array



"""

import numpy as np
from scipy.spatial import distance


class Array3D():
    def __init__(self, X, indices=None):
        if (X is None):
            raise Exception("Error: No data provided!")
        else:
            self.X = X.copy()
            self.array3D_size = max([self.X[x].shape[0] for x in range(len(self.X))])
            self.indices = indices.copy()

    def _group_gen(self, kromosom):
        distances = np.ma.masked_array(distance.cdist(self.X[kromosom],
                                                      self.sets,
                                                      self.metric))

        n_gen_kromosom = self.X[kromosom].shape[0]
        n_gen_prev = self.sets.shape[0]
        gen_kromosom = np.array([-1] * n_gen_kromosom)
        gen_prev = np.array([-1] * n_gen_prev)
        n_iterasi = min(n_gen_kromosom, n_gen_prev)
        for i in range(n_iterasi):
            closest = np.unravel_index(distances.argmin(), distances.shape)
            distances[closest[0], :] = np.ma.masked
            distances[:, closest[1]] = np.ma.masked

            if (self.method == 'centroids'):
                self.centroids[closest[1]].append((kromosom, closest[0]))
            self.sets[closest[1]] = self.X[kromosom][closest[0]]
            gen_kromosom[closest[0]] = closest[1]
            gen_prev[closest[1]] = closest[0]

        if (n_gen_kromosom > n_gen_prev):
            gen_left = np.where(gen_kromosom == -1)[0]
            self.sets = np.vstack((self.sets,
                                   self.X[kromosom].take(gen_left, axis=0)))
            if (self.method == 'centroids'):
                set_id = n_gen_prev
                for gen_left in gen_left:
                    self.centroids[set_id].append((kromosom, gen_left))
                    set_id += 1

        new_slice = self.sets.copy()
        new_slice[np.where(gen_prev == -1)] = [np.nan] * self.X[kromosom].shape[1]
        self.array3D = np.dstack((self.array3D, new_slice))

        if (self.indices is not None):
            if (n_gen_kromosom > n_gen_prev):
                kromosom_ind = np.append(gen_prev, gen_left).tolist()
            else:
                kromosom_ind = gen_prev.tolist()
            for i in range(len(kromosom_ind)):
                if (kromosom_ind[i] != -1):
                    kromosom_ind[i] = self.indices[kromosom][kromosom_ind[i]]
                else:
                    kromosom_ind[i] = None
            self.indices3D += [kromosom_ind]

    def _reevaluate_centroids(self):
        new_centroids = []

        for set_id in self.centroids.keys():
            set_centroid = []
            for set_gen in self.centroids[set_id]:
                set_centroid.append(self.X[set_gen[0]][set_gen[1]])
            new_centroids.append(np.mean(np.asarray(set_centroid), axis=0))

        self.sets = np.asarray(new_centroids)

    def create(self, metric='euclidean', method='centroids'):
        self.metric = metric
        self.method = method

        self.sets = np.array(self.X[0])
        self.array3D = self.X[0]
        if (self.indices is not None):
            self.indices3D = [self.indices[0]]
        else:
            self.indices3D = None

        padding = np.array(self.X[0].shape[1] * [np.nan])[np.newaxis, :]
        for i in range(self.array3D_size - self.X[0].shape[0]):
            self.array3D = np.vstack((self.array3D, padding))

        if (method == 'onebyone'):
            for i in range(1, len(self.X)):
                self._group_gen(i)
        else:
            self.centroids = {}
            for i in range(self.array3D_size):
                if (i < self.X[0].shape[0]):
                    self.centroids[i] = [(0, i)]
                else:
                    self.centroids[i] = []
            for i in range(1, len(self.X)):
                self._group_gen(i)
                self._reevaluate_centroids()

        self.array3D = self.array3D.swapaxes(0, 2)
        self.array3D = self.array3D.swapaxes(1, 2)

        return self.array3D, self.indices3D

kromosom_grouped = []
indices = []
for kromosom in range(1, 25):
    kromosom_grouped.append(grouped_kromosom.get_group(kromosom).iloc[:, 1:].values.copy())
    indices.append(grouped_kromosom.get_group(kromosom).index.tolist())

arr, ind = Array3D(kromosom_grouped, indices=indices).create(method='centroids')

arr.shape

print(arr)

os.mkdir('/Users/almanabila/Desktop/skripsi/Array3D')
np.save('/Users/almanabila/Desktop/skripsi/Array3D/arr_' + str(1), arr)

"""# K-Means"""

import numpy as np
import random
from scipy.spatial import distance
from scipy import floor

import time
import matplotlib.pyplot as plt


class KMeans():

    def __init__(self, X):

        if (X is None):
            raise Exception("Error: No data provided!")
        else:
            self.X = X   # ndarray
            self.N = len(X)  # Number of genes

        self.mu = None  # ndarray
        self.clusters = None
        self.method = None

    def cluster_points(self):

        mu = self.mu
        clusters = {}
        X = self.X

        if (self.metric == 'fractional'):
            distances = np.asarray(distance.cdist(X,
                                                  mu,
                                                  lambda x1, x2: np.linalg.norm(x1-x2, ord=self.f)))
        else:
            distances = np.asarray(distance.cdist(X, mu, self.metric))

        distances = np.asarray((np.amin(distances, axis=1),
                                np.argmin(distances, axis=1)))

        for clust in range(self.K):
            clusters[clust] = np.where(distances[1] == clust)[0].tolist()

        self.clusters = clusters
        self.labels = np.asarray(distances[1], dtype=int)
        self.distances = distances

    def reevaluate_centers(self):

        clusters = self.clusters
        newmu = []
        keys = sorted(self.clusters.keys())
        for k in keys:
            newmu.append(np.mean(np.take(self.X, clusters[k], axis=0), axis=0))
        self.mu = np.asarray(newmu)

    def has_converged(self):

        mu = self.mu
        oldmu = self.oldmu
        d = np.ravel(oldmu - mu)
        return np.dot(d, d) <= self.tol

    def find_centers(self, method='random', metric='euclidean', f=0.5,
                     n_times=10, tol=1e-4, max_iter=300, K=1, verbose=False,
                     init_centers=None):

        self.K = K
        self.method = method
        self.metric = metric
        X = self.X.tolist()
        self.tol = tol

        # Check the parameters given
        if (len(self.X) == 0):
            raise ValueError("Please provide valid data to the algorithm.")
        if (floor(self.K) != self.K) or (self.K <= 0):
            raise ValueError("'k' must be an integer > 0, but its value"
                             " is {}".format(self.K))
        if (self.method not in ['random', 'k-means++']):
            raise ValueError("'method' must be either 'random' or 'k-means++',"
                             " but its value is {}".format(self.delta))
        if (floor(max_iter) != max_iter) or (max_iter < 0):
            raise ValueError("'max_iter' must be an integer > 0, but its value"
                             " is {}".format(self.K))

        if (metric == 'fractional'):
            self.f = f

        self.best_inertia = None
        self.best_clusters = None
        self.best_labels = None
        self.best_mu = None

        self.distances = np.asarray([[None], [None]])
        self.labels = None
        self.clusters = None

        # Run k-means algorithm n_times
        for i in range(n_times):
            if (verbose):
                print(i)

            self.oldmu = np.asarray(random.sample(X, K))

            # Initialize centers
            if (init_centers is None):
                self.init_centers()
            else:
                self.mu = init_centers

            # E-M steps
            for j in range(max_iter):
                if (not self.has_converged()):
                    self.oldmu = self.mu
                    # Assign all points in X to clusters
                    self.cluster_points()
                    # Reevaluate centers
                    self.reevaluate_centers()
                else:
                    if (verbose):
                        print("   Converged in iteration {}".format(j))
                    break

            # Calculate inertia (Sum of distances of samples to their closest
            # cluster center)
            inertia = np.sum(self.distances[0])
            if (self.best_inertia is None) or (inertia < self.best_inertia):
                self.best_inertia = inertia
                self.best_labels = self.labels
                self.best_clusters = self.clusters
                self.best_mu = self.mu

    def get_clusters(self):

        return self.best_clusters

    def get_labels(self):

        return np.array(self.best_labels)

    def get_best_k(self):

        return [i+1 for i in np.argsort(self.fs) if self.fs[i] < 0.85]

    def get_centers(self):

        return self.best_mu

    def get_centroids(self):

        return np.vstack(self.X.take(self.best_clusters[x], axis=0).mean(axis=0)
                         for x in self.best_clusters.keys())

    def dist_from_centers(self):

        cent = self.mu
        X = self.X

        if (self.metric == 'fractional'):
            D2 = np.amin(np.power(distance.cdist(X,
                                                 cent,
                                                 lambda x1, x2: np.linalg.norm(x1-x2, ord=self.f)),
                                  2),
                         axis=1).flatten(order='A')
        else:
            D2 = np.amin(np.power(distance.cdist(X, cent, self.metric), 2),
                         axis=1).flatten(order='A')

        self.D2 = D2

    def choose_next_center(self):

        probs = self.D2/self.D2.sum()
        cumprobs = probs.cumsum()
        r = random.random()
        ind = np.where(cumprobs >= r)[0][0]
        return self.X[ind].tolist()

    def init_centers(self):

        if (self.method == 'k-means++'):   # k-means++ initialization
            self.mu = np.asarray(random.sample(self.X.tolist(), 1))
            while (len(self.mu) < self.K):
                self.dist_from_centers()
                self.mu = np.vstack((self.mu, self.choose_next_center()))
        else:  # random initialization
            self.mu = np.asarray(random.sample(self.X.tolist(), self.K))

    def memoize(func):

        memo = {}

        def helper(*args):
            if args not in memo:
                memo[args] = func(*args)
            return memo[args]

        return helper

    def ak(self, k, Nd):

        if (k == 2):
            a_k = 1.0 - (3.0 / (4.0 * Nd))
        else:
            a_k = self.ak(k-1, Nd) + (1.0 - self.ak(k-1, Nd)) / 6.0
        return a_k

    def fk(self, maxk, metric='euclidean', method='random', f=0.5, n_times=10,
           max_iter=300, tol=1e-4, verbose=False):

        X = self.X
        Nd = self.N

        fs = np.zeros(maxk)

        self.K = 1
        Skm1 = 0

        for k in range(1, maxk+1):
            if (verbose):
                print("k = {}".format(k))

            self.K = k

            self.find_centers(K=k, max_iter=max_iter, n_times=n_times, tol=tol,
                              method=method)
            best_clusters = self.best_clusters
            best_mu = self.best_mu

            Sk = 0
            for clust in best_clusters.keys():
                if (self.metric == 'fractional'):
                    Sk = Sk + \
                         np.sum(np.square(distance.cdist(X.take(best_clusters[clust], axis=0),
                                                         best_mu[clust, np.newaxis],
                                                         lambda x1, x2: np.linalg.norm(x1-x2, ord=f))))
                else:
                    Sk = Sk + \
                         np.sum(np.square(distance.cdist(X.take(best_clusters[clust], axis=0),
                                                         best_mu[clust, np.newaxis],
                                                         metric)))
            if (k == 1):
                fs[0] = 1
            elif (Skm1 == 0):
                fs[k-1] = 1
            else:
                fs[k-1] = Sk / (self.ak(k, Nd)*Skm1)

            Skm1 = Sk

        self.fs = fs

    def plot_fk(self, maxk):

        fig = plt.figure()
        plt.plot(range(1, maxk+1), self.fs, 'ro-', alpha=0.6)
        print(self.fs)
        plt.xlabel('Number of clusters K', fontsize=16)
        plt.ylabel('f(K)', fontsize=16)
        foundfK = np.where(self.fs == min(self.fs))[0][0] + 1
        tit2 = 'f(K) finds %s clusters' % (foundfK)
        plt.title(tit2, fontsize=16)
        fig.show()
        return self.fs

"""## K-Means Clustering Across the Chromosome Axis"""

mode = 1

if (mode == 0):
    arr_centroids0 = np.nanmean(arr, axis=1)
elif (mode == 1):
    arr_centroids1 = np.nanmean(arr, axis=0)
else:
    arr_centroids2 = np.nanmean(arr, axis=0).T

model1 = KMeans(arr_centroids1)

model1.find_centers(method='random', metric='euclidean', f=None,
                   n_times=10, tol=1e-4, max_iter=300, K=30, verbose=False)

model1.get_clusters()

model1.get_labels()

model1.get_centers()

model1.get_centroids()

model1.fk(30, metric='euclidean', method='random', f=0.5, n_times=10,
        max_iter=300, tol=1e-4, verbose=False)

model1.plot_fk(30)

model1 = KMeans(arr_centroids1)

model1.find_centers(method='k-means++', metric='euclidean', f=None,
                   n_times=10, tol=1e-4, max_iter=300, K=2, verbose=False)

model1.get_clusters()

model1.get_labels()

model1.get_centers()

model1.get_centroids()

model1.fk(2, metric='euclidean', method='k-means++', f=0.5, n_times=10,
        max_iter=300, tol=1e-4, verbose=False)

model1.plot_fk(2)

filename = '/Users/almanabila/Desktop/skripsi/'
os.mkdir('/Users/almanabila/Desktop/skripsi/')

save_cluster_genes(filename + ('/gene_ids.txt'), ind, algo='array3D')

"""## K-Means Clustering Across the Gene Axis"""

mode = 0

if (mode == 0):
    arr_centroids0 = np.nanmean(arr, axis=1)
elif (mode == 1):
    arr_centroids1 = np.nanmean(arr, axis=0)
else:
    arr_centroids2 = np.nanmean(arr, axis=0).T

model2 = KMeans(arr_centroids0)

model2.find_centers(method='k-means++', metric='euclidean', f=None,
                   n_times=10, tol=1e-4, max_iter=300, K=10, verbose=False)

model2.get_clusters()

model2.get_labels()

model2.get_centers()

model2.get_centroids()

model2.fk(10, metric='euclidean', method='k-means++', f=0.5, n_times=10,
        max_iter=300, tol=1e-4, verbose=False)

model2.plot_fk(10)

"""## K-Means Clustering Across the Observation Axis"""

mode = 2

if (mode == 0):
    arr_centroids0 = np.nanmean(arr, axis=1)
elif (mode == 1):
    arr_centroids1 = np.nanmean(arr, axis=0)
else:
    arr_centroids2 = np.nanmean(arr, axis=0).T

model3 = KMeans(arr_centroids2)

model3.find_centers(method='k-means++', metric='euclidean', f=None,
                   n_times=10, tol=1e-4, max_iter=300, K=10, verbose=False)

model3.get_clusters()

model3.get_labels()

model3.get_centers()

model3.get_centroids()

model3.fk(10, metric='euclidean', method='k-means++', f=0.5, n_times=10,
        max_iter=300, tol=1e-4, verbose=False)

model3.plot_fk(10)